--- src/client.c	2020-08-24 13:33:11.601053763 -0500
+++ ../pgbouncer-a/pgbouncer/src/client.c	2020-08-24 09:30:38.677700648 -0500
@@ -26,6 +26,7 @@
 
 #include <usual/pgutil.h>
 
+
 static const char *hdr2hex(const struct MBuf *data, char *buf, unsigned buflen)
 {
 	const uint8_t *bin = data->data + data->read_pos;
@@ -805,6 +806,30 @@
 	return true;
 }
 
+char *insert_sub_string(const char *source_str, const char *pattern, const char *new_sub_str) {
+  char *match = strcasestr(source_str, pattern);
+  if (match != NULL) {
+    size_t len = strlen(source_str);
+    size_t n1 = match - source_str;
+    size_t n2 = strlen(new_sub_str);
+    size_t n3 = len - n1;
+    char *result = malloc(strlen(source_str) + n2 + 1);
+    if (result != NULL) {
+      memcpy(result, source_str, n1);
+      memcpy(result + n1, new_sub_str, n2);
+      memcpy(result + n1 + n2, match, n3 + 1);
+    }
+     return result;
+  } else {
+    return strdup(source_str);
+  }
+}
+
+const int Q_OFFSET_TO_QUERY_BODY = 5;
+char *const q_pattern1 = "commit";
+char *const q_pattern2 = "rollback";
+char *const new_sub_query = "select prepare_commit();"; //TODO move to config
+
 /* decide on packets of logged-in client */
 static bool handle_client_work(PgSocket *client, PktHdr *pkt)
 {
@@ -821,6 +846,7 @@
 			return false;
 		}
 		rfq_delta++;
+		//TODO alter the query
 		break;
 	case 'F':		/* FunctionCall */
 		rfq_delta++;
@@ -890,6 +916,95 @@
 	client->link->ready = false;
 	client->link->idle_tx = false;
 
+
+
+	/*
+	modify query if needed
+	*/
+
+	char *query_str, *stmt_str;
+	char *pkt_start = (char *) &sbuf->io->buf[sbuf->io->parse_pos];
+	if (pkt->type == 'Q') {
+		query_str = (char *) pkt_start + Q_OFFSET_TO_QUERY_BODY;
+	} else if (pkt->type == 'P') {
+		stmt_str = pkt_start + Q_OFFSET_TO_QUERY_BODY;
+		query_str = stmt_str + strlen(stmt_str) + 1;
+	}
+
+	if (query_str != NULL) {
+		size_t query_str_len = strlen(query_str);
+		char *new_query_str_tmp = insert_sub_string(query_str, q_pattern1, new_sub_query);
+		char *new_query_str = insert_sub_string(new_query_str_tmp, q_pattern2, new_sub_query);
+		size_t new_query_str_len = strlen(new_query_str);
+
+		if (query_str_len != new_query_str_len) {
+			/*TODO you may need only 1 type of these 2 types of logs*/
+			slog_debug(client, "original query: %s", query_str);
+			slog_debug(client, "modified query: %s", new_query_str);
+			log_generic(LG_INFO, NULL, "original query: %s", query_str);
+			log_generic(LG_INFO, NULL, "modified query: %s", new_query_str);
+
+			/* new query must fit in the buffer */
+			if ((int)(sbuf->io->recv_pos + strlen(new_query_str) - strlen(query_str)) > (int)cf_sbuf_len) {
+				slog_error(client, "rewritten query will not fit into the allocated buffer!");
+				log_generic(LG_INFO, NULL, "rewritten query will not fit into the allocated buffer!");
+				free(new_query_str_tmp);
+				free(new_query_str);
+				goto exit;
+			}
+
+			/* manipulate the buffer to replace query */
+			/* clone buffer */
+			char *new_io_buf = malloc(cf_sbuf_len);
+			if (new_io_buf == NULL) {
+				fatal_perror("malloc");
+			}
+			memcpy(new_io_buf, sbuf->io->buf, cf_sbuf_len);
+			int i = sbuf->io->parse_pos;
+			/* packet type */
+			new_io_buf[i++] = pkt->type;
+			/* packet length */
+			size_t new_pkt_len = pkt->len + strlen(new_query_str) - strlen(query_str) - 1;
+			new_io_buf[i++] = (new_pkt_len >> 24) & 255;
+			new_io_buf[i++] = (new_pkt_len >> 16) & 255;
+			new_io_buf[i++] = (new_pkt_len >> 8) & 255;
+			new_io_buf[i++] = new_pkt_len & 255;
+
+			/* statement str - for type P */
+			if (pkt->type == 'P') {
+				strcpy(&new_io_buf[i], stmt_str);
+				i += strlen(stmt_str) + 1;
+			}
+
+			/* query string */
+			strcpy(&new_io_buf[i], new_query_str);
+			i += strlen(new_query_str) + 1;
+			/* copy everything else in buffer */
+			char *remaining_buffer_ptr = query_str + strlen(query_str) + 1;
+			int remaining_buffer_len = (char *) &sbuf->io->buf[sbuf->io->recv_pos] - remaining_buffer_ptr;
+			memcpy(&new_io_buf[i], remaining_buffer_ptr, remaining_buffer_len);
+			i += remaining_buffer_len;
+			/* replace original buffer with new buffer */
+			memcpy(sbuf->io->buf, new_io_buf, i);
+			/* adjust buffer recv_pos index to new position */
+			sbuf->io->recv_pos = i;
+			/* update PktHdr structure */
+			pkt->len = new_pkt_len + 1;
+			iobuf_parse_all(sbuf->io, &pkt->data);
+			/* done */
+			free(new_io_buf);
+		}
+
+		free(new_query_str_tmp);
+		free(new_query_str);
+	}
+
+	/*
+	end of 'modify query if needed'
+	*/
+
+
+exit:
 	/* forward the packet */
 	sbuf_prepare_send(sbuf, &client->link->sbuf, pkt->len);
 
